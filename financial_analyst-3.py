# -*- coding: utf-8 -*-
"""Financial Analyst.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-DZx0vXsIbB7n88L1E6yxHypmjVMEHNG
"""

pip install yfinance pandas scikit-learn matplotlib prophet

import yfinance as yf
import pandas as pd

tickers = ['AAPL', 'MSFT', 'NVDA']
data = {}
for ticker in tickers:
    company = yf.Ticker(ticker)
    financials = company.financials.T
    balance = company.balance_sheet.T
    data[ticker] = financials.join(balance, lsuffix='_fin', rsuffix='_bal')

df = pd.concat(data)
df.reset_index(inplace=True)

df.head()

print(df.columns.tolist())

import pandas as pd
# --- pick correct columns robustly ---
def pick(col_substrings):
    for s in col_substrings:
        hits = [c for c in df.columns if s.lower() in c.lower()]
        if hits: return hits[0]
    raise KeyError(col_substrings)

LIAB  = pick(["Total Liabilities Net Minority Interest", "Total Liabilities", "Total Liab"])
ASSET = pick(["Total Assets"])
REV   = pick(["Total Revenue"])
OPINC = pick(["Operating Income"])
NET   = pick(["Net Income"])

# --- clean index & time ---
df = df.rename(columns={"level_0":"Ticker","level_1":"Period"})
df["Period"] = pd.to_datetime(df["Period"])
df = df.sort_values(["Ticker","Period"])

# --- core KPIs (with safe division) ---
eps = 1e-9
df["Debt Ratio"]       = df[LIAB] / (df[ASSET] + eps)
df["Operating Margin"] = df[OPINC] / (df[REV] + eps)
df["Profit Margin"]    = df[NET]   / (df[REV] + eps)

# --- growth & lag features per ticker ---
df["Revenue Growth"] = df.groupby("Ticker")[REV].pct_change()
for k in [REV, OPINC, NET]:
    df[f"{k}_lag1"] = df.groupby("Ticker")[k].shift(1)
    df[f"{k}_lag2"] = df.groupby("Ticker")[k].shift(2)

# --- tidy numeric cols, drop obvious NaNs from first rows of each ticker ---
feat_cols = ["Debt Ratio","Operating Margin","Profit Margin","Revenue Growth",
             f"{REV}_lag1", f"{REV}_lag2", f"{OPINC}_lag1", f"{NET}_lag1"]
df_model = df[["Ticker","Period",REV] + feat_cols].dropna()

df_model[["Ticker","Period",REV,"Debt Ratio","Operating Margin","Profit Margin"]].tail()

from xgboost import XGBRegressor
from sklearn.metrics import mean_absolute_percentage_error
preds = []; scores = {}

for tk, g in df_model.groupby("Ticker"):
    X = g[feat_cols]; y = g[REV]
    split = int(len(g)*0.8)
    Xtr,Xte,ytr,yte = X.iloc[:split],X.iloc[split:],y.iloc[:split],y.iloc[split:]
    mdl = XGBRegressor(n_estimators=300, learning_rate=0.05, max_depth=3, subsample=0.9, colsample_bytree=0.9, random_state=42)
    mdl.fit(Xtr, ytr)
    yhat = mdl.predict(Xte)
    scores[tk] = 100*mean_absolute_percentage_error(yte, yhat)  # MAPE %
    # one-step ahead forecast for next quarter:
    last = g.iloc[[-1]][feat_cols]
    preds.append({
    "Ticker": tk,
    "Next_Q_Revenue_Pred": float(mdl.predict(last).item())
})

print("MAPE by ticker (%):", {k: round(v,2) for k,v in scores.items()})
preds

for p in preds:
    tk = p["Ticker"]
    actual_latest = df_model[df_model["Ticker"]==tk][REV].iloc[-1]
    growth_pred = (p["Next_Q_Revenue_Pred"] - actual_latest) / actual_latest * 100
    print(f"{tk}: Predicted growth next quarter = {growth_pred:.2f}%")

import matplotlib.pyplot as plt
for tk in ['AAPL','MSFT','NVDA']:
    sub = df_model[df_model['Ticker']==tk]
    plt.figure()
    plt.plot(sub['Period'], sub[REV], marker='o', label='Actual')
    plt.axhline([p["Next_Q_Revenue_Pred"] for p in preds if p["Ticker"]==tk][0],
                color='r', linestyle='--', label='Next-Q Prediction')
    plt.title(f"{tk} Quarterly Revenue Trend")
    plt.legend()
    plt.show()

"""#Cash Flow Forecasting"""

import yfinance as yf
import pandas as pd

tickers = ['AAPL','MSFT','NVDA']
data = {}

for t in tickers:
    c = yf.Ticker(t)

    fin   = c.financials.T            # income statement
    bal   = c.balance_sheet.T         # balance sheet

    # cash flow can be exposed as .cashflow or .cash_flow depending on yfinance version
    try:
        cf = c.cashflow.T
        if cf is None or cf.empty: raise AttributeError
    except Exception:
        cf = getattr(c, "cash_flow", pd.DataFrame()).T

    # join what’s available
    frames = [fin]
    if not bal.empty: frames.append(bal)
    if cf is not None and not cf.empty: frames.append(cf)

    data[t] = pd.concat(frames, axis=1, join='outer')

df = pd.concat(data)
df.reset_index(inplace=True)

# ---- robust column picking helper
def pick(df_, options):
    for opt in options:
        hits = [c for c in df_.columns if opt.lower() in c.lower()]
        if hits: return hits[0]
    raise KeyError(f"None of {options} found")

# canonical column names (handles Yahoo variants)
LIAB   = pick(df, ["Total Liabilities Net Minority Interest","Total Liabilities","Total Liab"])
ASSET  = pick(df, ["Total Assets"])
REV    = pick(df, ["Total Revenue"])
OPINC  = pick(df, ["Operating Income"])
NET    = pick(df, ["Net Income"])

# cash flow column often appears under different labels
OCF    = pick(df, [
    "Operating Cash Flow",
    "Total Cash From Operating Activities",
    "Net cash provided by operating activities",
    "Net Cash Provided By Operating Activities"
])

# ---- cleanup & features
df = df.rename(columns={"level_0":"Ticker","level_1":"Period"})
df["Period"] = pd.to_datetime(df["Period"])
df = df.sort_values(["Ticker","Period"])

eps = 1e-9
df["Debt Ratio"]       = df[LIAB] / (df[ASSET] + eps)
df["Operating Margin"] = df[OPINC] / (df[REV] + eps)
df["Profit Margin"]    = df[NET]   / (df[REV] + eps)

# Liquidity/quality-of-earnings style KPI
df["OCF_to_NetIncome"] = df[OCF] / (df[NET] + eps)         # >1 is healthy
df["OCF_to_Revenue"]   = df[OCF] / (df[REV] + eps)         # cash conversion

# growth + lags
df["Revenue Growth"] = df.groupby("Ticker")[REV].pct_change()
for k in [REV, OPINC, NET, OCF]:
    df[f"{k}_lag1"] = df.groupby("Ticker")[k].shift(1)

# ready for modeling
feat_cols = ["Debt Ratio","Operating Margin","Profit Margin","Revenue Growth",
             "OCF_to_NetIncome","OCF_to_Revenue",
             f"{REV}_lag1", f"{OPINC}_lag1", f"{NET}_lag1", f"{OCF}_lag1"]
df_model = df[["Ticker","Period",REV] + feat_cols].dropna()

from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_absolute_percentage_error
from xgboost import XGBRegressor
import numpy as np
import pandas as pd

scores, preds = {}, []
for tk, g in df.dropna(subset=[REV]+feat_cols).groupby("Ticker"):
    g = g.sort_values("Period").copy()

    # log-transform target for stability
    g["y"] = np.log1p(g[REV])
    X, y = g[feat_cols], g["y"]

    # --- adaptive folds: at least 2, at most len(X)-1
    max_splits = max(2, min(5, len(X) - 1))
    if max_splits < 2:
        # too few samples: skip CV and just fit once
        mdl = XGBRegressor(n_estimators=300, learning_rate=0.05, max_depth=3,
                           subsample=0.9, colsample_bytree=0.9, random_state=42)
        mdl.fit(X, y)
        next_rev_pred = float(np.expm1(mdl.predict(X.iloc[[-1]])[0]))
        preds.append({"Ticker": tk, "Next_Q_Revenue_Pred": next_rev_pred})
        scores[tk] = None
        continue

    tscv = TimeSeriesSplit(n_splits=max_splits)
    fold_mape = []
    for tr, te in tscv.split(X):
        if len(te) == 0:  # safety
            continue
        mdl = XGBRegressor(n_estimators=600, learning_rate=0.03, max_depth=4,
                           subsample=0.9, colsample_bytree=0.9, random_state=42)
        mdl.fit(X.iloc[tr], y.iloc[tr])
        yhat = mdl.predict(X.iloc[te])
        fold_mape.append(
            100*mean_absolute_percentage_error(np.expm1(y.iloc[te]), np.expm1(yhat))
        )

    scores[tk] = round(float(np.mean(fold_mape)), 2) if fold_mape else None

    # final refit on all data for one-step-ahead
    mdl.fit(X, y)
    next_rev_pred = float(np.expm1(mdl.predict(X.iloc[[-1]])[0]))
    preds.append({"Ticker": tk, "Next_Q_Revenue_Pred": next_rev_pred})

print("TS CV MAPE (%):", scores)
pd.DataFrame(preds)

"""#or"""

def safe_qdf(attr_name, ticker_obj):
    # Try quarterly_<name>, fall back to annual
    q = getattr(ticker_obj, f"quarterly_{attr_name}", pd.DataFrame())
    if q is None or q.empty:
        q = getattr(ticker_obj, attr_name, pd.DataFrame())
    return q.T  # we’ll work with rows=time

tickers = ['AAPL','MSFT','NVDA']
data = {}
for t in tickers:
    c = yf.Ticker(t)
    fin = safe_qdf("financials", c)           # quarterly if available
    bal = safe_qdf("balance_sheet", c)
    try:
        cf  = safe_qdf("cashflow", c)
    except Exception:
        cf = safe_qdf("cash_flow", c)

    data[t] = pd.concat([fin, bal, cf], axis=1, join="outer")

df = pd.concat(data)
df.reset_index(inplace=True)
df = df.rename(columns={"level_0":"Ticker","level_1":"Period"})
df["Period"] = pd.to_datetime(df["Period"])
df = df.sort_values(["Ticker","Period"])
# (recompute LIAB/ASSET/REV/OPINC/NET/OCF with your pick() helper and rebuild features)

"""# (1) Add Variance Analysis (Budget vs Actual vs Forecast)"""

df_model["Budget"] = df_model.groupby("Ticker")[REV].shift(1) * 1.05  # assume 5% growth budget
df_model["Variance_vs_Budget"] = (df_model[REV] - df_model["Budget"]) / df_model["Budget"]
df_model["Variance_vs_Forecast"] = (df_model[REV] - df_model[f"{REV}_lag1"]) / df_model[f"{REV}_lag1"]

"""# (2) Add Free Cash Flow (FCF) & Cash Flow Coverage Metrics"""

CAPEX = pick(df, ["Capital Expenditure","Capital Expenditures"])
df["FCF"] = df[OCF] - df[CAPEX]
df["FCF_Margin"] = df["FCF"] / (df[REV] + eps)

"""# (3) Add Liquidity & Solvency Ratios"""

curr_assets   = df[pick(df, ["Current Assets"])]
curr_liab     = df[pick(df, ["Current Liabilities"])]
total_liab    = df[pick(df, ["Total Liabilities Net Minority Interest","Total Liabilities"])]
equity        = df[pick(df, ["Stockholders Equity","Total Equity Gross Minority Interest"])]
int_exp       = df[pick(df, ["Interest Expense","Interest Expense Non Operating"])]

df["Current_Ratio"]      = curr_assets / (curr_liab + eps)
df["Debt_to_Equity"]     = total_liab / (equity + eps)
df["Interest_Coverage"]  = df[OPINC] / (int_exp + eps)

"""# Verify (to make sure nothing is string-typed)"""

df[["Current_Ratio","Debt_to_Equity","Interest_Coverage"]].dtypes

"""# (4) Add Expense Forecasting (Biweekly Equivalent)"""

df_model["Biweekly_Opex"] = df[OPINC].abs() / 6.5  # ~6.5 biweeks per quarter

"""# (5) KPI Dashboard (Tableau/PowerBI-style in Python)"""

metrics = ["Revenue Growth","Profit Margin","FCF_Margin",
           "Current_Ratio","Debt_to_Equity"]

for m in metrics:
    if m not in df.columns:
        print("Skipping missing metric:", m)
        continue

    df_p = df[["Ticker","Period",m]].dropna()
    plt.figure(figsize=(6,3))
    for tk in df_p["Ticker"].unique():
        sub = df_p[df_p["Ticker"]==tk]
        plt.plot(sub["Period"], sub[m], marker='o', label=tk)
    plt.title(m)
    plt.legend()
    plt.show()

"""# (6) Trend & Variance Narratives (Like FP&A output)"""

eps = 1e-9
df["FCF"] = df[OCF] - df[CAPEX]
df["FCF_Margin"] = df["FCF"] / (df[REV] + eps)

# 2) Bring FCF_Margin into df_model
df_model = df_model.merge(
    df[["Ticker","Period","FCF_Margin"]],
    on=["Ticker","Period"],
    how="left"
)

# 3) Now this works:
latest = df_model.groupby("Ticker").tail(1)
for _, row in latest.iterrows():
    print(f"{row['Ticker']}:")
    print(f"- Operating Margin: {row['Operating Margin']:.2%}")
    print(f"- Profit Margin: {row['Profit Margin']:.2%}")
    print(f"- FCF Margin: {row['FCF_Margin']:.2%}")
    print(f"- Variance vs Budget: {row['Variance_vs_Budget']:.2%}\n")

"""# (7) Risk Scoring Model (Bank-style)"""

import numpy as np

def pick(df_, options):
    for opt in options:
        hits = [c for c in df_.columns if opt.lower() in c.lower()]
        if hits: return hits[0]
    raise KeyError(f"None of {options} found in columns")

# Re-pick the primitives on *this* df
LIAB   = pick(df, ["Total Liabilities Net Minority Interest","Total Liabilities","Total Liab"])
ASSET  = pick(df, ["Total Assets"])
REV    = pick(df, ["Total Revenue"])
OPINC  = pick(df, ["Operating Income"])
NET    = pick(df, ["Net Income"])
OCF    = pick(df, [
    "Operating Cash Flow",
    "Total Cash From Operating Activities",
    "Net cash provided by operating activities",
    "Net Cash Provided By Operating Activities"
])
CAPEX  = pick(df, ["Capital Expenditure","Capital Expenditures"])
CURR_A = pick(df, ["Current Assets"])
CURR_L = pick(df, ["Current Liabilities"])
EQUITY = pick(df, ["Stockholders Equity","Total Equity Gross Minority Interest"])
INTEXP = pick(df, ["Interest Expense","Interest Expense Non Operating"])

# (Re)compute derived metrics on df
eps = 1e-9
df["Operating Margin"] = df[OPINC] / (df[REV] + eps)
df["Profit Margin"]    = df[NET]   / (df[REV] + eps)
df["Debt_to_Equity"]   = df[LIAB]  / (df[EQUITY] + eps)
df["Current_Ratio"]    = df[CURR_A] / (df[CURR_L] + eps)
df["Interest_Coverage"]= df[OPINC] / (df[INTEXP] + eps)
df["FCF"]              = df[OCF] - df[CAPEX]
df["FCF_Margin"]       = df["FCF"] / (df[REV] + eps)

# (Optional) sanity-check they exist
need = ["Operating Margin","Current_Ratio","Debt_to_Equity"]
missing = [c for c in need if c not in df.columns]
assert not missing, f"Missing metrics: {missing}"

df["Risk_Score"] = (
    (df["Debt_to_Equity"] > 2).astype(int)*2 +
    (df["Current_Ratio"] < 1).astype(int)*2 +
    (df["Operating Margin"] < 0).astype(int)*1
)

"""# (8) Headcount Proxy (Expense-per-Employee)"""

SGA = pick(df, ["Selling General And Administration"])
df["Employee_Cost_Index"] = df[SGA] / df[REV]

"""# (9) Operating Expense Forecast (Biweekly) YOY Trend"""

df["Biweekly_Opex"] = df[OPINC].abs() / 6.5
df["Biweekly_Opex_YoY"] = df.groupby("Ticker")["Biweekly_Opex"].pct_change(4)

# === 0) Robust resolver + standardize names ===
def pick_one(df_, options):
    for opt in options:
        hits = [c for c in df_.columns if opt.lower() in c.lower()]
        if hits: return hits[0]
    return None  # don't raise yet

cols_map = {
    "REV":  pick_one(df, ["Total Revenue","Operating Revenue"]),
    "OPINC":pick_one(df, ["Operating Income","Total Operating Income As Reported"]),
    "NET":  pick_one(df, ["Net Income","Net Income From Continuing Operation Net Minority Interest"]),
    "OCF":  pick_one(df, ["Operating Cash Flow","Total Cash From Operating Activities",
                          "Net cash provided by operating activities","Net Cash Provided By Operating Activities"]),
    "ASSET":pick_one(df, ["Total Assets"]),
    "LIAB": pick_one(df, ["Total Liabilities Net Minority Interest","Total Liabilities","Total Liab"]),
    "EQUITY":pick_one(df, ["Stockholders Equity","Total Equity Gross Minority Interest"]),
    "CURR_ASSET":pick_one(df, ["Current Assets"]),
    "CURR_LIAB": pick_one(df, ["Current Liabilities"]),
    "INT_EXP": pick_one(df, ["Interest Expense","Interest Expense Non Operating"]),
    "CAPEX":  pick_one(df, ["Capital Expenditure","Capital Expenditures"])
}

# sanity: see what's missing
missing = [k for k,v in cols_map.items() if v is None]
if missing:
    print("WARNING: Missing columns for keys:", missing)

# rename only the ones we found to canonical short names
rename_map = {v:k for k,v in cols_map.items() if v is not None}
df = df.rename(columns=rename_map)

# Ensure key canonicals exist as columns (some might be missing if Yahoo didn't provide them)
for must in ["REV","OPINC","NET","ASSET","LIAB"]:
    if must not in df.columns:
        raise KeyError(f"Required column not found after standardization: {must}")

# === 1) Sort and base features ===
df["Period"] = pd.to_datetime(df["Period"])
df = df.sort_values(["Ticker","Period"])
eps = 1e-9

df["Debt_Ratio"]       = df["LIAB"]  / (df["ASSET"] + eps)
df["Operating_Margin"] = df["OPINC"] / (df["REV"]   + eps)
df["Profit_Margin"]    = df["NET"]   / (df["REV"]   + eps)
df["Revenue_Growth"]   = df.groupby("Ticker")["REV"].pct_change()

# === 2) Liquidity/quality-of-earnings (only if present) ===
if "OCF" in df.columns:
    df["OCF_to_NetIncome"] = df["OCF"] / (df["NET"] + eps)
    df["OCF_to_Revenue"]   = df["OCF"] / (df["REV"] + eps)
else:
    df["OCF_to_NetIncome"] = pd.NA
    df["OCF_to_Revenue"]   = pd.NA

# === 3) Lags (only for columns that exist) ===
for k in ["REV","OPINC","NET","OCF"]:
    if k in df.columns:
        df[f"{k}_lag1"] = df.groupby("Ticker")[k].shift(1)
        df[f"{k}_lag2"] = df.groupby("Ticker")[k].shift(2)

# === 4) FCF & cash metrics (guard CAPEX/OCF presence) ===
if "OCF" in df.columns and "CAPEX" in df.columns:
    df["FCF"] = df["OCF"] - df["CAPEX"]
    df["FCF_Margin"] = df["FCF"] / (df["REV"] + eps)

# === 5) Liquidity & solvency ratios (guard presence) ===
if "CURR_ASSET" in df.columns and "CURR_LIAB" in df.columns:
    df["Current_Ratio"] = df["CURR_ASSET"] / (df["CURR_LIAB"] + eps)
if "LIAB" in df.columns and "EQUITY" in df.columns:
    df["Debt_to_Equity"] = df["LIAB"] / (df["EQUITY"] + eps)
if "INT_EXP" in df.columns:
    df["Interest_Coverage"] = df["OPINC"] / (df["INT_EXP"] + eps)

# === 6) Biweekly Opex and YoY (do it in df to avoid scope issues) ===
df["Biweekly_Opex"] = df["OPINC"].abs() / 6.5
df["Biweekly_Opex_YoY"] = df.groupby("Ticker")["Biweekly_Opex"].pct_change(4)

# === 7) Build modeling frame from canonical names ===
feat_cols = [
    "Debt_Ratio","Operating_Margin","Profit_Margin","Revenue_Growth",
    "OCF_to_NetIncome","OCF_to_Revenue",
    "REV_lag1","REV_lag2","OPINC_lag1","NET_lag1","OCF_lag1",
    "Biweekly_Opex","Biweekly_Opex_YoY","Current_Ratio","Debt_to_Equity","Interest_Coverage","FCF_Margin"
]

# keep only features that exist
feat_cols = [c for c in feat_cols if c in df.columns]

df_model = df[["Ticker","Period","REV"] + feat_cols].dropna()

# debug helper: see if anything still missing
expected = set(["Ticker","Period","REV"] + feat_cols)
missing_now = list(expected - set(df.columns))
if missing_now:
    print("Note: these expected columns were not present and were skipped:", missing_now)

print(df_model.tail(3)[["Ticker","Period","REV"] + feat_cols])

company_info = c.get_info()
emp = company_info.get("fullTimeEmployees", None)
fin["Employee_Count"] = emp

employee_counts = {}
for t in tickers:
    company = yf.Ticker(t)
    employee_counts[t] = company.get_info().get("fullTimeEmployees", None)

df["Employee_Count"] = df["Ticker"].map(employee_counts)

print(sorted(df.columns.tolist()))

# Use canonical columns already in your df
REV    = "REV"
OPINC  = "OPINC"              # or "Operating Income" if you prefer
NET    = "NET"
ASSET  = "ASSET"
LIAB   = "LIAB"
OCF    = "OCF"
CAPEX  = "CAPEX"
INTEXP = "INT_EXP"

eps = 1e-9

# Core ratios (safe divide)
df["Debt_Ratio"]       = df[LIAB] / (df[ASSET] + eps)
df["Operating_Margin"] = df[OPINC] / (df[REV]   + eps)
df["Profit_Margin"]    = df[NET]   / (df[REV]   + eps)

# Growth & lags
df["Revenue_Growth"] = df.groupby("Ticker")[REV].pct_change()
for k in [REV, OPINC, NET, OCF]:
    df[f"{k}_lag1"] = df.groupby("Ticker")[k].shift(1)
    df[f"{k}_lag2"] = df.groupby("Ticker")[k].shift(2)

# Cash flow / FCF
df["FCF"]        = df[OCF] - df[CAPEX]
df["FCF_Margin"] = df["FCF"] / (df[REV] + eps)

# Liquidity / solvency
df["Current_Ratio"]     = df["CURR_ASSET"] / (df["CURR_LIAB"] + eps) if "CURR_ASSET" in df and "CURR_LIAB" in df else df["Current Assets"]/(df["Current Liabilities"]+eps)
df["Debt_to_Equity"]    = df[LIAB] / (df["EQUITY"] + eps)
df["Interest_Coverage"] = df[OPINC] / (df[INTEXP] + eps)

# ----- Biweekly OPEX (use Operating Expense, not Operating Income) -----
if "Operating Expense" in df.columns:
    df["Biweekly_Opex"] = df["Operating Expense"].abs() / 6.5  # ~6.5 biweeks per quarter
elif "Total Expenses" in df.columns:
    df["Biweekly_Opex"] = df["Total Expenses"].abs() / 6.5
else:
    # graceful fallback: estimate OPEX as (Revenue - Operating Income)
    df["Biweekly_Opex"] = (df[REV] - df[OPINC]).abs() / 6.5

# YoY change (quarterly → 4-period lag)
df["Biweekly_Opex_YoY"] = df.groupby("Ticker")["Biweekly_Opex"].pct_change(4)

# Build modeling frame
feat_cols = [
    "Debt_Ratio","Operating_Margin","Profit_Margin","Revenue_Growth",
    f"{REV}_lag1", f"{REV}_lag2", f"{OPINC}_lag1", f"{NET}_lag1",
    "OCF_to_NetIncome","OCF_to_Revenue","FCF_Margin"
]
# Create OCF_to_* if missing
df["OCF_to_NetIncome"] = df[OCF]/(df[NET]+eps)
df["OCF_to_Revenue"]   = df[OCF]/(df[REV]+eps)

df_model = df[["Ticker","Period",REV] + feat_cols].dropna()

!pip install xlsxwriter

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

eps = 1e-9

# 0) Helpers to find common banking lines if Yahoo names vary
def pick_one(df_, options):
    for opt in options:
        hits = [c for c in df_.columns if opt.lower() in c.lower()]
        if hits:
            return hits[0]
    return None

# Try to locate key banking lines (best-effort; some tickers may miss a few)
col_NII  = pick_one(df, ["Net Interest Income", "Net Interest Income Bank", "Net Interest Income-"])
col_NIR  = pick_one(df, ["Non Interest Income", "Non-Interest Income", "Other Income", "Total Non Interest Income"])
col_OPEX = pick_one(df, ["Operating Expense", "Total Expenses", "Non Interest Expense", "Non-Interest Expense"])
col_LOANS = pick_one(df, ["Total Loans Net", "Loans Net", "Net Loans"])
col_DEPOSITS = pick_one(df, ["Total Deposits", "Deposits", "Customer Deposits"])

# 1) Banking KPIs (with proxies if needed)
if col_NII is not None:
    df["NII"] = df[col_NII]
if col_NIR is not None:
    df["NIR"] = df[col_NIR]
if col_OPEX is not None:
    df["OPEX_line"] = df[col_OPEX]
else:
    # proxy OPEX if not explicitly reported: OPEX ≈ Revenue - Operating Income
    df["OPEX_line"] = (df["REV"] - df["OPINC"]).abs()

# Average earning assets proxy: use average Total Assets (2-period mean)
df["AvgAssets_proxy"] = df.groupby("Ticker")["ASSET"].transform(lambda s: (s.shift(1) + s) / 2)

# Net Interest Margin proxy (since earning assets not always available)
if "NII" in df.columns:
    df["NIM_proxy"] = df["NII"] / (df["AvgAssets_proxy"] + eps)
else:
    df["NIM_proxy"] = np.nan

# Efficiency Ratio = OPEX / (NII + NIR)
if "NII" in df.columns and "NIR" in df.columns:
    df["Efficiency_Ratio"] = df["OPEX_line"] / (df["NII"] + df["NIR"] + eps)
else:
    # fallback to cost-to-income
    df["Efficiency_Ratio"] = df["OPEX_line"] / (df["REV"] + eps)

# Cost-to-Income
df["Cost_to_Income"] = df["OPEX_line"] / (df["REV"] + eps)

# Loans/Deposits (if available)
if col_LOANS is not None and col_DEPOSITS is not None:
    df["Loans_to_Deposits"] = df[col_LOANS] / (df[col_DEPOSITS] + eps)

# Non-interest income growth (explicit for JD)
if "NIR" in df.columns:
    df["NonInterest_Growth"] = df.groupby("Ticker")["NIR"].pct_change()

# 2) Biweekly forecasts (NIR & OPEX) — simple, stable FP&A approach
#    Convert quarterly values to "per-biweek" levels (≈ 6.5 biweeks per quarter)
df["Biweekly_Opex"] = df["OPEX_line"].abs() / 6.5
if "NIR" in df.columns:
    df["Biweekly_NIR"] = df["NIR"] / 6.5

# Rolling mean + AR(1)-like drift forecast for the next 4 biweeks
def biweekly_forecast(series, horizon=4):
    s = series.dropna()
    if len(s) == 0:
        return [np.nan]*horizon
    if len(s) == 1:
        return [float(s.iloc[-1])]*horizon
    # recent trend (quarter-over-quarter level change mapped to biweekly)
    delta = float(s.iloc[-1] - s.iloc[-2])
    level = float(s.iloc[-1])
    # smooth baseline with rolling mean
    base = float(pd.Series(s).rolling(4, min_periods=1).mean().iloc[-1])
    # combine: start from base, then apply damped drift
    out = []
    for h in range(1, horizon+1):
        level = level + 0.4*delta  # damp drift
        # blend to baseline
        blended = 0.7*level + 0.3*base
        out.append(blended)
        # decay delta
        delta *= 0.65
    return out

bi_forecasts = []
for tk, g in df.sort_values("Period").groupby("Ticker"):
    row = {"Ticker": tk}
    row["Biweekly_Opex_Forecast"] = biweekly_forecast(g["Biweekly_Opex"])
    if "Biweekly_NIR" in g.columns:
        row["Biweekly_NIR_Forecast"] = biweekly_forecast(g["Biweekly_NIR"])
    else:
        row["Biweekly_NIR_Forecast"] = [np.nan]*4
    bi_forecasts.append(row)

bi_fore_df = pd.DataFrame(bi_forecasts)

# 3) Headcount analytics (if Employee_Count exists or map if you’ve added earlier)
if "Employee_Count" not in df.columns:
    # best-effort: try pull once per ticker (optional)
    try:
        import yfinance as yf
        employee_counts = {}
        for t in df["Ticker"].unique():
            try:
                info = yf.Ticker(t).get_info()
            except Exception:
                info = {}
            employee_counts[t] = info.get("fullTimeEmployees", np.nan)
        df["Employee_Count"] = df["Ticker"].map(employee_counts)
    except Exception:
        df["Employee_Count"] = np.nan

df["Rev_per_Employee"]  = df["REV"] / (df["Employee_Count"] + eps)
df["Opex_per_Employee"] = df["OPEX_line"] / (df["Employee_Count"] + eps)
df["Productivity_Delta"] = df.groupby("Ticker")["Rev_per_Employee"].pct_change()

# 4) Budget vs Forecast vs Actual: extend your exec table to include banking KPIs
# Reuse "Budget" if you already created; otherwise:
if "Budget" not in df.columns:
    df["Budget"] = df.groupby("Ticker")["REV"].shift(1) * 1.05

# Executive summary per last reported quarter
last_rows = df.groupby("Ticker").tail(1).copy()
exec_cols = ["Ticker","Period","REV","Budget","Operating_Margin","Profit_Margin",
             "FCF_Margin","Efficiency_Ratio","Cost_to_Income","NIM_proxy",
             "Biweekly_Opex","Employee_Count","Rev_per_Employee","Opex_per_Employee"]
exec_cols = [c for c in exec_cols if c in last_rows.columns]
exec_table_bank = last_rows[exec_cols].rename(columns={"REV":"Actual_Rev"}).reset_index(drop=True)

# Attach your model’s next-Q revenue forecast if you produced preds earlier
if "preds_df" in locals() and {"Ticker","Next_Q_Revenue_Pred"}.issubset(preds_df.columns):
    exec_table_bank["Forecast_NextQ"] = exec_table_bank["Ticker"].map(
        dict(zip(preds_df["Ticker"], preds_df["Next_Q_Revenue_Pred"]))
    )
    exec_table_bank["Var_vs_Budget_%"] = (exec_table_bank["Actual_Rev"] - exec_table_bank["Budget"]) / (exec_table_bank["Budget"] + eps) * 100
else:
    exec_table_bank["Forecast_NextQ"] = np.nan
    exec_table_bank["Var_vs_Budget_%"] = np.nan

# 5) Variance waterfall inputs (drivers: NII, NIR, OPEX)
# For banks, Revenue ≈ NII + NIR (simplified)
def build_waterfall_inputs(g):
    g = g.sort_values("Period")
    if len(g) < 2:
        return None
    prior = g.iloc[-2]
    curr  = g.iloc[-1]
    prior_rev = float(prior["REV"])
    curr_rev  = float(curr["REV"])
    nii_change = float((curr.get("NII", np.nan) - prior.get("NII", np.nan)) if "NII" in g.columns else np.nan)
    nir_change = float((curr.get("NIR", np.nan) - prior.get("NIR", np.nan)) if "NIR" in g.columns else np.nan)
    opex_change= float((curr["OPEX_line"] - prior["OPEX_line"]))
    # Residual/Other to tie out
    explained = sum([v for v in [nii_change, nir_change, -opex_change] if pd.notna(v)])
    other = (curr_rev - prior_rev) - explained
    return {
        "Prior_Rev": prior_rev,
        "ΔNII": nii_change if np.isfinite(nii_change) else 0.0,
        "ΔNIR": nir_change if np.isfinite(nir_change) else 0.0,
        "−ΔOPEX": -opex_change,
        "Other": other,
        "Current_Rev": curr_rev
    }

waterfalls = []
for tk, g in df.groupby("Ticker"):
    wf = build_waterfall_inputs(g.copy())
    if wf:
        wf["Ticker"] = tk
        waterfalls.append(wf)
waterfall_df = pd.DataFrame(waterfalls)

# (Optional) Quick waterfall chart per ticker (kept minimal; one plot per chart)
def plot_waterfall(wf_row):
    labels = ["Prior_Rev","ΔNII","ΔNIR","−ΔOPEX","Other","Current_Rev"]
    vals = [wf_row[l] for l in labels]
    # Build cumulative for steps
    cum = [vals[0]]
    for i in range(1, len(vals)-1):
        cum.append(cum[-1] + vals[i])
    cum.append(vals[-1])  # final equals Current_Rev

    plt.figure()
    x = range(len(labels))
    # Prior bar
    plt.bar(0, vals[0])
    # Changes as floating bars
    base = vals[0]
    for i in range(1, len(labels)-1):
        y0 = base
        h  = vals[i]
        plt.bar(i, h, bottom=y0)
        base = y0 + h
    # Current bar
    plt.bar(len(labels)-1, vals[-1])
    plt.xticks(x, labels, rotation=20)
    plt.title(f"{wf_row['Ticker']} – Revenue Waterfall (QoQ)")
    plt.ylabel("Value")
    plt.show()

# Example: plot for first available ticker
if len(waterfall_df):
    plot_waterfall(waterfall_df.iloc[0])

# 6) Scenario table (bear/base/bull) extended with Opex tightening and fee swing
scenarios_ext = []
for tk, g in df.groupby("Ticker"):
    g = g.sort_values("Period")
    # Baselines
    last_rev  = float(g["REV"].iloc[-1])
    last_opm  = float(g["Operating_Margin"].dropna().iloc[-1]) if g["Operating_Margin"].notna().any() else 0.2
    last_opex = float(g["OPEX_line"].iloc[-1])
    last_nir  = float(g["NIR"].iloc[-1]) if "NIR" in g.columns and g["NIR"].notna().any() else 0.0
    # If you computed a Next_Q_Revenue_Pred earlier, use it as base; else carry forward
    if "preds_df" in locals() and {"Ticker","Next_Q_Revenue_Pred"}.issubset(preds_df.columns):
        base_rev = float(preds_df.loc[preds_df["Ticker"]==tk, "Next_Q_Revenue_Pred"].values[0])
    else:
        base_rev = last_rev

    scenario_defs = [
        ("Bear", 0.97, 1.03, 0.97),  # Rev -3%, Opex +3%, NIR -3%
        ("Base", 1.00, 1.00, 1.00),
        ("Bull", 1.03, 0.98, 1.03),  # Rev +3%, Opex -2%, NIR +3%
    ]
    for name, rev_mult, opex_mult, nir_mult in scenario_defs:
        rev = base_rev * rev_mult
        # approximate OPINC from margin; enforce OPEX accordingly
        opinc_est = rev * last_opm
        opex_est  = max(rev - opinc_est, 0.0) * opex_mult
        nir_est   = last_nir * nir_mult
        scenarios_ext.append({
            "Ticker": tk, "Scenario": name,
            "Rev": rev, "OpInc_est": opinc_est, "Opex_est": opex_est, "NIR_est": nir_est,
            "Efficiency_Ratio_est": (opex_est / ( (rev - opex_est) + nir_est + eps)) if (rev - opex_est) >= 0 else np.nan
        })

scenario_ext_df = pd.DataFrame(scenarios_ext)

# 7) Narrative/risk flags per ticker (JD asks for observations & recommendations)
def budget_flag(v):
    if pd.isna(v): return "N/A"
    if v > 5:  return "Over Budget"
    if v < -5: return "Under Budget"
    return "On Target"

narratives = []
for tk, g in df.groupby("Ticker"):
    g = g.sort_values("Period")
    last = g.iloc[-1]
    flags = {
        "Budget_Flag": budget_flag(((last["REV"] - (g["REV"].shift(1).iloc[-1]*1.05)) / ((g["REV"].shift(1).iloc[-1]*1.05)+eps))*100) if len(g) >= 2 else "N/A",
        "IC_Flag": "Watch" if ("Interest_Coverage" in g.columns and pd.notna(last.get("Interest_Coverage", np.nan)) and last["Interest_Coverage"] < 3) else "OK",
        "Efficiency_Flag": "Tighten Opex" if pd.notna(last.get("Efficiency_Ratio", np.nan)) and last["Efficiency_Ratio"] > 0.55 else "Healthy",
        "Opex_Pressure": "Rising" if pd.notna(last.get("Biweekly_Opex_YoY", np.nan)) and last["Biweekly_Opex_YoY"] > 0.08 else "Stable/Falling"
    }
    narratives.append({
        "Ticker": tk,
        "Operating_Margin": last.get("Operating_Margin", np.nan),
        "Profit_Margin": last.get("Profit_Margin", np.nan),
        "FCF_Margin": last.get("FCF_Margin", np.nan),
        "Efficiency_Ratio": last.get("Efficiency_Ratio", np.nan),
        "Cost_to_Income": last.get("Cost_to_Income", np.nan),
        "NIM_proxy": last.get("NIM_proxy", np.nan),
        "Biweekly_Opex_YoY": last.get("Biweekly_Opex_YoY", np.nan),
        **flags
    })

narratives_df = pd.DataFrame(narratives)

# 8) Excel FP&A pack export (executive summary, scenarios, biweekly forecasts, KPIs)
#    This is interview gold — they love Excel.
from pandas import ExcelWriter

def melt_kpis_for_bi(df_):
    keep = ["Ticker","Period","REV","OPINC","NET","OPEX_line","NII","NIR",
            "Operating_Margin","Profit_Margin","FCF_Margin","NIM_proxy",
            "Efficiency_Ratio","Cost_to_Income","Biweekly_Opex"]
    keep = [c for c in keep if c in df_.columns]
    return df_[keep].copy().sort_values(["Ticker","Period"])

with pd.ExcelWriter("Axos_FP&A_Pack.xlsx", engine="xlsxwriter") as xl:
    exec_table_bank.to_excel(xl, "Executive_Summary", index=False)
    scenario_ext_df.to_excel(xl, "Scenarios", index=False)
    melt_kpis_for_bi(df).to_excel(xl, "KPIs_TimeSeries", index=False)
    waterfall_df.to_excel(xl, "Waterfall_Inputs", index=False)
    narratives_df.to_excel(xl, "Narratives_Flags", index=False)
    # Flatten biweekly forecasts
    bi_flat = []
    for _, r in bi_fore_df.iterrows():
        for i, val in enumerate(r["Biweekly_Opex_Forecast"], start=1):
            bi_flat.append({"Ticker": r["Ticker"], "Metric":"Biweekly_Opex", f"T+{i}": val})
        for i, val in enumerate(r["Biweekly_NIR_Forecast"], start=1):
            bi_flat.append({"Ticker": r["Ticker"], "Metric":"Biweekly_NIR", f"T+{i}": val})
    bi_flat_df = pd.DataFrame(bi_flat)
    bi_flat_df.to_excel(xl, "Biweekly_Forecasts", index=False)

print("Saved: Axos_FP&A_Pack.xlsx")

# 9) (Optional) Quick visuals — one chart per figure, no explicit colors
# Biweekly Opex trend per ticker
for tk, g in df.dropna(subset=["Biweekly_Opex"]).groupby("Ticker"):
    plt.figure()
    plt.plot(g["Period"], g["Biweekly_Opex"], marker="o")
    plt.title(f"{tk} – Biweekly Opex Trend")
    plt.xlabel("Period"); plt.ylabel("Opex per Biweek")
    plt.show()

# Non-interest income trend (if present)
if "NIR" in df.columns:
    for tk, g in df.dropna(subset=["NIR"]).groupby("Ticker"):
        plt.figure()
        plt.plot(g["Period"], g["NIR"], marker="o")
        plt.title(f"{tk} – Non-Interest Income")
        plt.xlabel("Period"); plt.ylabel("NIR (Quarterly)")
        plt.show()

# 10) Print short, interview-ready narrative
print("\n=== Executive Summary (Banking) ===")
display(exec_table_bank)

print("\n=== Narratives / Risk Flags ===")
display(narratives_df)

print("\n=== Biweekly Forecasts (flat) ===")
display(bi_flat_df.head(12))

# ===============================
# (A) Attach Forecast_NextQ properly
# ===============================
from xgboost import XGBRegressor
import numpy as np

forecast_map = {}

for tk, g in df_model.groupby("Ticker"):
    g = g.sort_values("Period")

    # log transform target
    y = np.log1p(g["REV"])
    X = g[feat_cols]

    mdl = XGBRegressor(
        n_estimators=300, learning_rate=0.05, max_depth=3,
        subsample=0.9, colsample_bytree=0.9, random_state=42
    )
    mdl.fit(X, y)

    # one-step ahead prediction
    last = g[feat_cols].iloc[[-1]]
    raw_pred = mdl.predict(last)
    pred = float(np.expm1(float(raw_pred.ravel()[0])))
    forecast_map[tk] = pred

# attach into exec table
exec_table_bank["Forecast_NextQ"] = exec_table_bank["Ticker"].map(forecast_map)


# ===============================
# (B) Compute variance vs budget (%)
# ===============================
exec_table_bank["Var_vs_Budget_%"] = (
    (exec_table_bank["Forecast_NextQ"] - exec_table_bank["Budget"])
    / exec_table_bank["Budget"]
)*100


# ===============================
# (C) Fill any numeric gaps
# ===============================
exec_table_bank = exec_table_bank.fillna({
    "Forecast_NextQ": 0,
    "Var_vs_Budget_%": 0
})


# ===============================
# (D) Final pretty print
# ===============================
print("\n=== FINAL Executive Summary With Forecasts ===")
print(exec_table_bank.to_string(index=False))